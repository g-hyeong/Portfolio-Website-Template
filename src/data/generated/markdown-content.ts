// 자동 생성된 마크다운 콘텐츠 모듈

export const markdownContent: Record<string, string> = {
  "react-performance-optimization": "# React 성능 최적화 기법\n\nReact 애플리케이션의 성능을 향상시키기 위한 다양한 최적화 기법들을 정리해보겠습니다.\n\n## 1. React.memo와 useMemo\n\n불필요한 리렌더링을 방지하기 위해 React.memo와 useMemo를 활용할 수 있습니다.\n\n```jsx\n// React.memo 사용\nconst ExpensiveComponent = React.memo(({ data }) => {\n  return <div>{data.map(item => <Item key={item.id} data={item} />)}</div>;\n});\n\n// useMemo 사용\nconst expensiveValue = useMemo(() => {\n  return data.filter(item => item.active).map(item => item.value);\n}, [data]);\n```\n\n## 2. 가상화 (Virtualization)\n\n대량의 데이터를 렌더링할 때는 가상화 기법을 사용하여 성능을 개선할 수 있습니다.\n\n```jsx\nimport { FixedSizeList as List } from 'react-window';\n\nconst VirtualizedList = ({ items }) => (\n  <List\n    height={600}\n    itemCount={items.length}\n    itemSize={35}\n  >\n    {({ index, style }) => (\n      <div style={style}>\n        {items[index].name}\n      </div>\n    )}\n  </List>\n);\n```\n\n## 3. 코드 분할 (Code Splitting)\n\n동적 import를 사용하여 번들 크기를 줄이고 초기 로딩 시간을 개선할 수 있습니다.\n\n```jsx\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </Suspense>\n  );\n}\n```\n\n## 4. 이미지 최적화\n\nNext.js의 Image 컴포넌트를 사용하여 이미지를 최적화할 수 있습니다.\n\n```jsx\nimport Image from 'next/image';\n\n<Image\n  src=\"/path/to/image.jpg\"\n  alt=\"Description\"\n  width={500}\n  height={300}\n  priority\n  placeholder=\"blur\"\n/>\n```\n\n## 결론\n\nReact 성능 최적화는 단순히 하나의 기법만으로는 해결되지 않습니다. 애플리케이션의 특성에 맞는 적절한 최적화 기법들을 조합하여 사용하는 것이 중요합니다.",
  "next-js-ssr-guide": "# Next.js SSR 완벽 가이드\n\nNext.js의 Server-Side Rendering(SSR)에 대한 상세한 가이드와 실무 적용 사례를 다룹니다.\n\n## SSR vs CSR vs SSG\n\n### Server-Side Rendering (SSR)\n- 서버에서 HTML을 생성하여 클라이언트에 전송\n- SEO에 유리하고 초기 로딩이 빠름\n- 서버 부하가 있을 수 있음\n\n### Client-Side Rendering (CSR)\n- 클라이언트에서 JavaScript로 DOM을 생성\n- 인터랙티브한 사용자 경험\n- 초기 로딩이 느릴 수 있음\n\n### Static Site Generation (SSG)\n- 빌드 시점에 HTML을 미리 생성\n- 가장 빠른 로딩 속도\n- 동적 데이터 처리에 제한\n\n## getServerSideProps 활용\n\n```jsx\nexport async function getServerSideProps(context) {\n  const { req, res, query } = context;\n  \n  // 서버에서 데이터 패칭\n  const data = await fetchData(query.id);\n  \n  // 404 처리\n  if (!data) {\n    return {\n      notFound: true,\n    };\n  }\n  \n  // 리다이렉트\n  if (data.redirectTo) {\n    return {\n      redirect: {\n        destination: data.redirectTo,\n        permanent: false,\n      },\n    };\n  }\n  \n  return {\n    props: {\n      data,\n    },\n  };\n}\n```\n\n## 데이터 패칭 최적화\n\n### SWR 사용\n```jsx\nimport useSWR from 'swr';\n\nfunction Profile() {\n  const { data, error } = useSWR('/api/user', fetcher);\n  \n  if (error) return <div>Failed to load</div>;\n  if (!data) return <div>Loading...</div>;\n  \n  return <div>Hello {data.name}!</div>;\n}\n```\n\n### React Query 사용\n```jsx\nimport { useQuery } from 'react-query';\n\nfunction Posts() {\n  const { data, isLoading, error } = useQuery('posts', fetchPosts);\n  \n  if (isLoading) return 'Loading...';\n  if (error) return 'An error occurred';\n  \n  return (\n    <ul>\n      {data.map(post => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## 성능 최적화\n\n### 동적 라우팅\n```jsx\n// pages/posts/[id].js\nexport async function getServerSideProps({ params }) {\n  const post = await getPost(params.id);\n  \n  return {\n    props: {\n      post,\n    },\n  };\n}\n```\n\n### 캐싱 전략\n```jsx\nexport async function getServerSideProps({ res }) {\n  // 캐시 헤더 설정\n  res.setHeader(\n    'Cache-Control',\n    'public, s-maxage=10, stale-while-revalidate=59'\n  );\n  \n  const data = await fetchData();\n  \n  return {\n    props: {\n      data,\n    },\n  };\n}\n```\n\n## 실무 팁\n\n1. **API 라우트 활용**: `/pages/api` 디렉토리를 활용하여 백엔드 API 구축\n2. **미들웨어 사용**: 인증, 로깅 등을 위한 미들웨어 구성\n3. **환경변수 관리**: `.env.local` 파일을 통한 환경변수 관리\n4. **타입스크립트 적용**: 타입 안정성을 위한 TypeScript 사용\n\n## 결론\n\nNext.js의 SSR은 SEO와 성능을 동시에 만족시킬 수 있는 강력한 기능입니다. 프로젝트의 요구사항에 맞게 적절한 렌더링 전략을 선택하는 것이 중요합니다.",
  "database-design-patterns": "# 데이터베이스 설계 패턴\n\n효율적인 데이터베이스 설계를 위한 다양한 패턴과 모범 사례들을 정리했습니다.\n\n## 1. 정규화와 비정규화\n\n### 정규화 (Normalization)\n데이터 중복을 최소화하고 데이터 무결성을 보장하는 과정입니다.\n\n```sql\n-- 정규화된 테이블 구조\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL\n);\n\nCREATE TABLE orders (\n    id SERIAL PRIMARY KEY,\n    user_id INTEGER REFERENCES users(id),\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE order_items (\n    id SERIAL PRIMARY KEY,\n    order_id INTEGER REFERENCES orders(id),\n    product_id INTEGER REFERENCES products(id),\n    quantity INTEGER NOT NULL,\n    price DECIMAL(10,2) NOT NULL\n);\n```\n\n### 비정규화 (Denormalization)\n성능 향상을 위해 의도적으로 중복을 허용하는 기법입니다.\n\n```sql\n-- 비정규화된 테이블 (리포팅용)\nCREATE TABLE user_order_summary (\n    user_id INTEGER,\n    user_name VARCHAR(100),\n    total_orders INTEGER,\n    total_amount DECIMAL(12,2),\n    last_order_date TIMESTAMP\n);\n```\n\n## 2. 인덱싱 전략\n\n### 기본 인덱스\n```sql\n-- 기본 키는 자동으로 인덱스 생성\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10,2),\n    category_id INTEGER\n);\n\n-- 외래 키에 인덱스 추가\nCREATE INDEX idx_products_category ON products(category_id);\n\n-- 복합 인덱스\nCREATE INDEX idx_products_category_price ON products(category_id, price);\n```\n\n### 부분 인덱스\n```sql\n-- 조건부 인덱스\nCREATE INDEX idx_active_users ON users(email) WHERE status = 'active';\n```\n\n## 3. 관계 설계 패턴\n\n### One-to-Many\n```sql\nCREATE TABLE categories (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    category_id INTEGER REFERENCES categories(id)\n);\n```\n\n### Many-to-Many\n```sql\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE roles (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) NOT NULL\n);\n\nCREATE TABLE user_roles (\n    user_id INTEGER REFERENCES users(id),\n    role_id INTEGER REFERENCES roles(id),\n    PRIMARY KEY (user_id, role_id)\n);\n```\n\n## 4. 성능 최적화 패턴\n\n### 파티셔닝\n```sql\n-- 날짜 기반 파티셔닝\nCREATE TABLE orders (\n    id SERIAL,\n    user_id INTEGER,\n    created_at DATE,\n    amount DECIMAL(10,2)\n) PARTITION BY RANGE (created_at);\n\nCREATE TABLE orders_2023 PARTITION OF orders\n    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');\n```\n\n### 캐싱 전략\n```sql\n-- 머터리얼라이즈드 뷰\nCREATE MATERIALIZED VIEW monthly_sales AS\nSELECT \n    DATE_TRUNC('month', created_at) as month,\n    SUM(amount) as total_sales,\n    COUNT(*) as order_count\nFROM orders\nGROUP BY DATE_TRUNC('month', created_at);\n\n-- 주기적 갱신\nREFRESH MATERIALIZED VIEW monthly_sales;\n```\n\n## 5. 데이터 타입 선택\n\n### 적절한 데이터 타입 사용\n```sql\n-- 잘못된 예\nCREATE TABLE bad_example (\n    id VARCHAR(50),          -- 숫자인데 VARCHAR 사용\n    price VARCHAR(20),       -- 금액인데 VARCHAR 사용\n    created_at VARCHAR(50)   -- 날짜인데 VARCHAR 사용\n);\n\n-- 올바른 예\nCREATE TABLE good_example (\n    id SERIAL PRIMARY KEY,\n    price DECIMAL(10,2),\n    created_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n## 6. 트랜잭션 설계\n\n### ACID 속성 보장\n```sql\nBEGIN;\n    UPDATE accounts SET balance = balance - 100 WHERE id = 1;\n    UPDATE accounts SET balance = balance + 100 WHERE id = 2;\n    INSERT INTO transactions (from_account, to_account, amount) \n    VALUES (1, 2, 100);\nCOMMIT;\n```\n\n## 결론\n\n데이터베이스 설계는 애플리케이션의 성능과 확장성에 직접적인 영향을 미칩니다. 초기 설계 단계에서 충분한 고려와 계획이 필요하며, 지속적인 모니터링과 최적화가 중요합니다.",
  "docker-deployment-guide": "# Docker를 활용한 배포 전략\n\nDocker 컨테이너를 활용한 효율적인 애플리케이션 배포 방법과 CI/CD 파이프라인 구축에 대해 설명합니다.\n\n## Docker 기본 개념\n\n### 컨테이너 vs 가상머신\n- **컨테이너**: OS 커널을 공유하여 가벼운 가상화\n- **가상머신**: 하드웨어를 가상화하여 완전한 OS 실행\n\n### Dockerfile 작성\n```dockerfile\n# Next.js 애플리케이션 Dockerfile\nFROM node:18-alpine AS deps\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine AS runner\nWORKDIR /app\nENV NODE_ENV production\n\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 nextjs\n\nCOPY --from=builder /app/public ./public\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static\n\nUSER nextjs\n\nEXPOSE 3000\nENV PORT 3000\n\nCMD [\"node\", \"server.js\"]\n```\n\n## Docker Compose 활용\n\n### 개발 환경 구성\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=development\n      - DATABASE_URL=postgresql://user:password@db:5432/myapp\n    depends_on:\n      - db\n      - redis\n    volumes:\n      - .:/app\n      - /app/node_modules\n\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: myapp\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n\nvolumes:\n  postgres_data:\n```\n\n### 프로덕션 환경 구성\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    image: myapp:latest\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n    restart: unless-stopped\n    deploy:\n      replicas: 3\n      resources:\n        limits:\n          memory: 512M\n        reservations:\n          memory: 256M\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n      - ./ssl:/etc/nginx/ssl\n    depends_on:\n      - app\n    restart: unless-stopped\n```\n\n## CI/CD 파이프라인\n\n### GitHub Actions 워크플로우\n```yaml\nname: Deploy to Production\n\non:\n  push:\n    branches: [main]\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v2\n    \n    - name: Login to DockerHub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    \n    - name: Build and push Docker image\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: myapp:${{ github.sha }},myapp:latest\n        cache-from: type=gha\n        cache-to: type=gha,mode=max\n    \n    - name: Deploy to production\n      uses: appleboy/ssh-action@v0.1.5\n      with:\n        host: ${{ secrets.HOST }}\n        username: ${{ secrets.USERNAME }}\n        key: ${{ secrets.PRIVATE_KEY }}\n        script: |\n          docker pull myapp:latest\n          docker-compose down\n          docker-compose up -d\n          docker system prune -f\n```\n\n## 배포 전략\n\n### Blue-Green 배포\n```bash\n#!/bin/bash\n\n# 현재 활성 환경 확인\nCURRENT=$(docker-compose ps -q app | wc -l)\n\nif [ $CURRENT -eq 0 ]; then\n    # 첫 배포\n    docker-compose up -d\nelse\n    # Blue-Green 배포\n    docker-compose -f docker-compose.blue.yml up -d\n    \n    # 헬스 체크\n    sleep 30\n    if curl -f http://localhost:3001/health; then\n        # 트래픽 전환\n        docker-compose down\n        docker-compose -f docker-compose.blue.yml down\n        mv docker-compose.blue.yml docker-compose.yml\n        docker-compose up -d\n    else\n        echo \"Deployment failed\"\n        docker-compose -f docker-compose.blue.yml down\n        exit 1\n    fi\nfi\n```\n\n### Rolling 업데이트\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    image: myapp:latest\n    deploy:\n      replicas: 3\n      update_config:\n        parallelism: 1\n        delay: 10s\n        failure_action: rollback\n        order: start-first\n      rollback_config:\n        parallelism: 1\n        delay: 5s\n```\n\n## 모니터링과 로깅\n\n### 로그 수집\n```yaml\nservices:\n  app:\n    logging:\n      driver: \"json-file\"\n      options:\n        max-size: \"10m\"\n        max-file: \"3\"\n```\n\n### 헬스 체크\n```dockerfile\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:3000/health || exit 1\n```\n\n## 보안 고려사항\n\n### 멀티스테이지 빌드\n- 프로덕션 이미지에서 개발 의존성 제거\n- 최소한의 런타임 환경 구성\n\n### 비루트 사용자\n```dockerfile\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 nextjs\nUSER nextjs\n```\n\n### 시크릿 관리\n```yaml\nservices:\n  app:\n    secrets:\n      - db_password\n      - api_key\n\nsecrets:\n  db_password:\n    external: true\n  api_key:\n    external: true\n```\n\n## 결론\n\nDocker를 활용한 배포는 일관된 환경, 확장성, 그리고 효율적인 리소스 관리를 제공합니다. 적절한 CI/CD 파이프라인과 함께 사용하면 안정적이고 빠른 배포가 가능합니다.",
  "aws-architecture-decisions": "# AWS 아키텍처 설계 회고\n\n대규모 웹 애플리케이션을 위한 AWS 클라우드 아키텍처 설계 과정과 배운 점들을 정리했습니다.\n\n## 프로젝트 개요\n\n### 요구사항\n- 월 1000만 PV 처리 가능한 웹 애플리케이션\n- 99.9% 가용성 보장\n- 글로벌 사용자 대응\n- 비용 효율적인 운영\n\n### 초기 아키텍처 설계\n\n```\nInternet Gateway\n       ↓\nApplication Load Balancer\n       ↓\nAuto Scaling Group (EC2)\n       ↓\nRDS (Multi-AZ)\n```\n\n## 아키텍처 진화 과정\n\n### 1단계: 기본 3-Tier 아키텍처\n\n```yaml\n# 초기 설정\nVPC: 10.0.0.0/16\nPublic Subnets: 10.0.1.0/24, 10.0.2.0/24\nPrivate Subnets: 10.0.10.0/24, 10.0.20.0/24\nDatabase Subnets: 10.0.100.0/24, 10.0.200.0/24\n```\n\n**문제점:**\n- 단일 리전으로 인한 가용성 위험\n- 정적 자산 로딩 속도 이슈\n- 데이터베이스 성능 병목\n\n### 2단계: CDN 및 캐싱 도입\n\n```\nCloudFront (CDN)\n       ↓\nS3 (Static Assets)\n       ↓\nApplication Load Balancer\n       ↓\nAuto Scaling Group\n       ↓\nElastiCache (Redis)\n       ↓\nRDS (Read Replica 추가)\n```\n\n**개선점:**\n- CloudFront로 글로벌 캐싱\n- Redis로 세션 및 데이터 캐싱\n- RDS Read Replica로 읽기 성능 향상\n\n### 3단계: 마이크로서비스 아키텍처\n\n```\nAPI Gateway\n       ↓\nLambda Functions (Serverless)\n       ↓\nSQS/SNS (Message Queue)\n       ↓\nDynamoDB (NoSQL)\n       ↓\nRDS (Core Data)\n```\n\n## 주요 의사결정과 근거\n\n### 1. EC2 vs Lambda\n```python\n# Lambda 함수 예시\nimport json\nimport boto3\n\ndef lambda_handler(event, context):\n    # 이벤트 처리 로직\n    dynamodb = boto3.resource('dynamodb')\n    table = dynamodb.Table('users')\n    \n    response = table.get_item(\n        Key={'user_id': event['user_id']}\n    )\n    \n    return {\n        'statusCode': 200,\n        'body': json.dumps(response['Item'])\n    }\n```\n\n**선택 기준:**\n- **Lambda**: 비정기적, 짧은 실행 시간\n- **EC2**: 장시간 실행, 상태 유지 필요\n\n### 2. RDS vs DynamoDB\n```sql\n-- RDS (관계형 데이터)\nSELECT u.name, COUNT(o.id) as order_count\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id;\n```\n\n```python\n# DynamoDB (NoSQL)\nimport boto3\n\ndynamodb = boto3.resource('dynamodb')\ntable = dynamodb.Table('user-orders')\n\nresponse = table.query(\n    KeyConditionExpression=Key('user_id').eq('123')\n)\n```\n\n**선택 기준:**\n- **RDS**: 복잡한 쿼리, 트랜잭션 필요\n- **DynamoDB**: 높은 확장성, 단순한 쿼리\n\n### 3. Application Load Balancer vs Network Load Balancer\n\n```yaml\n# ALB 설정\nType: Application\nScheme: internet-facing\nListeners:\n  - Port: 80\n    Protocol: HTTP\n    Default Actions:\n      - Type: redirect\n        RedirectConfig:\n          Protocol: HTTPS\n          Port: 443\n          StatusCode: HTTP_301\n  - Port: 443\n    Protocol: HTTPS\n    Certificates:\n      - CertificateArn: arn:aws:acm:...\n```\n\n**선택한 이유:**\n- HTTP/HTTPS 트래픽 처리\n- 경로 기반 라우팅 필요\n- SSL/TLS 종료 기능\n\n## 성능 최적화\n\n### CloudWatch 모니터링\n```python\nimport boto3\n\ncloudwatch = boto3.client('cloudwatch')\n\n# 커스텀 메트릭 전송\ncloudwatch.put_metric_data(\n    Namespace='MyApp/Performance',\n    MetricData=[\n        {\n            'MetricName': 'ResponseTime',\n            'Value': response_time,\n            'Unit': 'Milliseconds',\n            'Dimensions': [\n                {\n                    'Name': 'Environment',\n                    'Value': 'production'\n                }\n            ]\n        }\n    ]\n)\n```\n\n### Auto Scaling 정책\n```yaml\nAutoScalingPolicy:\n  - PolicyName: ScaleUpPolicy\n    ScalingAdjustment: 2\n    Cooldown: 300\n    MetricName: CPUUtilization\n    ComparisonOperator: GreaterThanThreshold\n    Threshold: 70\n  \n  - PolicyName: ScaleDownPolicy\n    ScalingAdjustment: -1\n    Cooldown: 300\n    MetricName: CPUUtilization\n    ComparisonOperator: LessThanThreshold\n    Threshold: 30\n```\n\n## 비용 최적화\n\n### Reserved Instances vs Spot Instances\n```bash\n# 비용 분석 스크립트\naws ce get-cost-and-usage \\\n    --time-period Start=2023-01-01,End=2023-12-31 \\\n    --granularity MONTHLY \\\n    --metrics BlendedCost \\\n    --group-by Type=DIMENSION,Key=SERVICE\n```\n\n**전략:**\n- 기본 용량: Reserved Instances (1년 예약)\n- 피크 트래픽: Spot Instances\n- 버스트 트래픽: On-Demand Instances\n\n### S3 스토리지 클래스\n```yaml\nLifecycleConfiguration:\n  Rules:\n    - Status: Enabled\n      Transitions:\n        - Days: 30\n          StorageClass: STANDARD_IA\n        - Days: 90\n          StorageClass: GLACIER\n        - Days: 365\n          StorageClass: DEEP_ARCHIVE\n```\n\n## 보안 고려사항\n\n### IAM 역할 기반 액세스\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"dynamodb:GetItem\",\n        \"dynamodb:PutItem\",\n        \"dynamodb:Query\"\n      ],\n      \"Resource\": \"arn:aws:dynamodb:region:account:table/MyTable\"\n    }\n  ]\n}\n```\n\n### VPC 보안 그룹\n```yaml\nSecurityGroups:\n  WebTier:\n    - Protocol: TCP\n      Port: 80,443\n      Source: 0.0.0.0/0\n  \n  AppTier:\n    - Protocol: TCP\n      Port: 8080\n      Source: WebTier-SG\n  \n  DatabaseTier:\n    - Protocol: TCP\n      Port: 5432\n      Source: AppTier-SG\n```\n\n## 배운 점들\n\n### 1. 점진적 마이그레이션\n- 한 번에 모든 것을 바꾸지 말고 단계적으로 진행\n- 각 단계별로 충분한 테스트와 모니터링\n\n### 2. 비용 모니터링의 중요성\n- 예상보다 높은 데이터 전송 비용\n- CloudWatch 로그 저장 비용 최적화 필요\n\n### 3. 장애 대응 계획\n```bash\n# 장애 시나리오별 대응 스크립트\n#!/bin/bash\n\ncase $1 in\n  \"database\")\n    # RDS 페일오버\n    aws rds failover-db-cluster --db-cluster-identifier myapp-cluster\n    ;;\n  \"application\")\n    # Auto Scaling 강제 스케일아웃\n    aws autoscaling set-desired-capacity --auto-scaling-group-name myapp-asg --desired-capacity 10\n    ;;\nesac\n```\n\n## 결론\n\nAWS 아키텍처 설계는 비즈니스 요구사항, 성능, 비용, 보안을 모두 고려해야 하는 복합적인 과정입니다. 중요한 것은 초기에 완벽한 설계보다는 요구사항 변화에 따라 유연하게 진화할 수 있는 구조를 만드는 것입니다.\n\n### 권장사항\n1. Well-Architected Framework 활용\n2. 정기적인 비용 검토\n3. 자동화된 모니터링 및 알림\n4. 재해 복구 계획 수립\n5. 지속적인 성능 최적화",
};
